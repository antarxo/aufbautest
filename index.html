<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aufbau Διάγραμμα</title>
  <!-- Χρήση της βιβλιοθήκης p5.js για γραφική απεικόνιση -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { text-align: center; font-family: Verdana, sans-serif; }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
  <h1>Aufbau Διάγραμμα</h1>
  <label for="atomicNumber">Ατομικός Αριθμός:</label>
  <input type="number" id="atomicNumber" min="1" max="118" value="1">
  <button onclick="startFilling()">Ξεκίνα Δόμηση</button>
  
  <script>
    /* 
      Ορισμός των περιόδων σύμφωνα με το σχήμα:
      
      K:  1s
      L:  2s   2p
      M:  3s   3p   3d
      N:  4s   4p   4d   4f
      O:  5s   5p   5d   5f
      P:  6s   6p   6d
      Q:  7s   7p
    */
    let periods = [
      { label: "K", orbitals: ["1s"] },
      { label: "L", orbitals: ["2s", "2p"] },
      { label: "M", orbitals: ["3s", "3p", "3d"] },
      { label: "N", orbitals: ["4s", "4p", "4d", "4f"] },
      { label: "O", orbitals: ["5s", "5p", "5d", "5f"] },
      { label: "P", orbitals: ["6s", "6p", "6d"] },
      { label: "Q", orbitals: ["7s", "7p"] }
    ];
    
    // Μέγιστος αριθμός ηλεκτρονίων για κάθε orbital
    let maxElectrons = { "s": 2, "p": 6, "d": 10, "f": 14 };
    
    // Σταθερές σχεδίασης
    let boxWidth = 60, boxHeight = 40, verticalSpacing = 70;
    let canvasWidth = 800, canvasHeight = 500;
    
    // Array για αποθήκευση των δεδομένων κάθε orbital (σε επίπεδη δομή)
    // Κάθε στοιχείο θα έχει: x, y, label, filled και col (στήλη μέσα στην περίοδο)
    let positions = [];
    
    /* 
      Η σειρά συμπλήρωσης (Aufbau order) ορίζεται ως εξής:
      1s, 2s, 2p, 3s, 3p, 4s, 3d, 4p, 5s, 4d, 5p, 6s, 4f, 5d, 6p, 7s, 5f, 6d, 7p
      Δηλαδή, ως indices στα positions: [0, 1, 2, 3, 4, 6, 5, 7, 10, 8, 11, 14, 9, 12, 15, 17, 13, 16, 18]
    */
    let fillOrder = [0, 1, 2, 3, 4, 6, 5, 7, 10, 8, 11, 14, 9, 12, 15, 17, 13, 16, 18];
    
    // Ορισμός χρωμάτων για τις στήλες (κάθε στήλη θα έχει το δικό της χρώμα)
    let columnColors = [];
    function initColumnColors() {
      // Παράδειγμα: 4 διαφορετικά pastel χρώματα για στήλες 0 έως 3
      columnColors = [color("#FFCDD2"), color("#C8E6C9"), color("#BBDEFB"), color("#FFF9C4")];
    }
    
    // Υπολογισμός θέσεων: κάθε περίοδος (γραμμή) κεντράρεται οριζόντια
    function calculatePositions() {
      positions = [];
      let startY = 50;
      for (let i = 0; i < periods.length; i++) {
        let rowOrbitals = periods[i].orbitals;
        let gap = 10;
        let totalRowWidth = rowOrbitals.length * boxWidth + (rowOrbitals.length - 1) * gap;
        let startX = (canvasWidth - totalRowWidth) / 2 + boxWidth / 2;
        let y = startY + i * verticalSpacing;
        for (let j = 0; j < rowOrbitals.length; j++) {
          let x = startX + j * (boxWidth + gap);
          positions.push({ x: x, y: y, label: rowOrbitals[j], filled: 0, col: j });
        }
      }
    }
    
    // Σχεδίαση βελών: για κάθε orbital στο fillOrder, σχεδιάζεται κατακόρυφη γραμμή από το κάτω κέντρο του κουτιού 
    // μέχρι ένα κοινό baseline (που υπολογίζεται ώστε να είναι κάτω από όλα τα ορθογώνια),
    // και μετά μια οριζόντια γραμμή που ενώνει όλα τα σημεία με ένα απαλό γαλάζιο χρώμα.
    function drawArrows() {
      // Βρες το χαμηλότερο σημείο από τα ορθογώνια
      let maxBottom = 0;
      for (let pos of positions) {
        let bottom = pos.y + boxHeight/2;
        if (bottom > maxBottom) maxBottom = bottom;
      }
      let baseline = maxBottom + 20;  // κάτω από όλα τα ορθογώνια
      
      // Χρησιμοποιούμε απαλό γαλάζιο για τα βέλη
      let arrowColor = color(173, 216, 230);
      stroke(arrowColor);
      strokeWeight(2);
      
      let arrowPoints = [];
      // Για κάθε orbital στο fillOrder, σχεδίασε κατακόρυφη γραμμή από το κάτω κέντρο του κουτιού μέχρι το baseline.
      for (let idx of fillOrder) {
        let pos = positions[idx];
        let xCenter = pos.x;
        let yBottom = pos.y + boxHeight/2;
        // Δε σχεδιάζουμε “ανόδικα” βέλη: το baseline έχει οριστεί κάτω από όλα
        line(xCenter, yBottom, xCenter, baseline);
        arrowPoints.push({ x: xCenter, y: baseline });
      }
      
      // Σχεδίασε οριζόντια γραμμή που ενώνει όλα τα σημεία του baseline.
      for (let i = 0; i < arrowPoints.length - 1; i++) {
        let pt1 = arrowPoints[i];
        let pt2 = arrowPoints[i+1];
        line(pt1.x, pt1.y, pt2.x, pt2.y);
      }
      // Σχεδίασε την κεφαλή του βέλους στο τέλος της οριζόντιας γραμμής.
      let lastPt = arrowPoints[arrowPoints.length - 1];
      push();
      translate(lastPt.x, lastPt.y);
      let arrowSize = 7;
      triangle(0, 0, -arrowSize, arrowSize/2, -arrowSize, -arrowSize/2);
      pop();
    }
    
    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      textSize(12);
      textFont("Verdana");
      initColumnColors();
      calculatePositions();
      noLoop();
    }
    
    function draw() {
      background(255);
      
      // Σχεδίαση των ονομάτων των περιόδων στα αριστερά
      textAlign(RIGHT, CENTER);
      let periodLabels = ["K", "L", "M", "N", "O", "P", "Q"];
      for (let i = 0; i < periodLabels.length; i++) {
        let y = 50 + i * verticalSpacing;
        text(periodLabels[i], 100, y);
      }
      
      // Σχεδίαση των ορθογωνίων για κάθε orbital, χρησιμοποιώντας το χρώμα της αντίστοιχης στήλης
      noStroke();
      for (let pos of positions) {
        let colIndex = pos.col;  // κάθε στήλη έχει διαφορετικό χρώμα
        let colColor = columnColors[colIndex % columnColors.length];
        fill(colColor);
        rectMode(CENTER);
        rect(pos.x, pos.y, boxWidth, boxHeight);
        fill(0);
        text(pos.label + " (" + pos.filled + ")", pos.x, pos.y);
      }
      
      // Σχεδίαση των βελών
      drawArrows();
    }
    
    // Συνάρτηση δόμησης: κατανέμει τα ηλεκτρόνια στα orbitals σύμφωνα με τον ατομικό αριθμό και τη σειρά Aufbau.
    function startFilling() {
      // Επαναφορά των τιμών συμπλήρωσης
      for (let pos of positions) {
        pos.filled = 0;
      }
      let atomicNumber = parseInt(document.getElementById("atomicNumber").value);
      let remaining = atomicNumber;
      for (let i = 0; i < fillOrder.length; i++) {
        let idx = fillOrder[i];
        let orbital = positions[idx];
        let orbType = orbital.label.slice(-1); // παίρνουμε τον τύπο: s, p, d ή f
        let capacity = maxElectrons[orbType] || 2;
        let fillAmount = min(remaining, capacity);
        orbital.filled = fillAmount;
        remaining -= fillAmount;
        if (remaining <= 0) break;
      }
      redraw();
    }
  </script>
</body>
</html>
