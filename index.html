<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aufbau Διάγραμμα</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { text-align: center; font-family: Arial, sans-serif; }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
  <h1>Aufbau Διάγραμμα</h1>
  <label for="atomicNumber">Ατομικός Αριθμός:</label>
  <input type="number" id="atomicNumber" min="1" max="118" value="1">
  <button onclick="startFilling()">Ξεκίνα Δόμηση</button>
  
  <script>
    // Ορισμός των περιόδων (στιβάδων) σύμφωνα με το σχήμα:
    // 1η:    1s
    // 2η:    2s   2p
    // 3η:    3s   3p   3d
    // 4η:    4s   4p   4d   4f
    // 5η:    5s   5p   5d   5f
    // 6η:    6s   6p   6d
    // 7η:    7s   7p
    let periods = [
      ["1s"],
      ["2s", "2p"],
      ["3s", "3p", "3d"],
      ["4s", "4p", "4d", "4f"],
      ["5s", "5p", "5d", "5f"],
      ["6s", "6p", "6d"],
      ["7s", "7p"]
    ];
    
    // Παράμετροι σχεδίασης
    let boxWidth = 60;
    let boxHeight = 40;
    let verticalSpacing = 70;
    let canvasWidth = 600;
    let canvasHeight = 600;
    
    // Οι μέγιστοι αριθμοί ηλεκτρονίων για κάθε τύπο orbital
    let maxElectrons = { "s": 2, "p": 6, "d": 10, "f": 14 };
    
    // positions: πίνακας που θα περιέχει τα αντικείμενα για κάθε orbital με τις θέσεις του
    let positions = [];
    
    // fillOrder: ορίζουμε τη σειρά συμπλήρωσης με διάβαση των περιόδων από πάνω προς τα κάτω, αριστερά προς τα δεξιά
    let fillOrder = [];
    
    // Υπολογισμός θέσεων ώστε κάθε σειρά να είναι κεντραρισμένη
    function calculatePositions() {
      positions = [];
      fillOrder = [];
      let startY = 50;
      let idx = 0;
      for (let i = 0; i < periods.length; i++) {
        let row = periods[i];
        let gap = 10;
        let totalRowWidth = row.length * boxWidth + (row.length - 1) * gap;
        // Κεντραρισμός της σειράς στο canvas
        let startX = (canvasWidth - totalRowWidth) / 2 + boxWidth / 2;
        for (let j = 0; j < row.length; j++) {
          let x = startX + j * (boxWidth + gap);
          let y = startY + i * verticalSpacing;
          positions.push({
            x: x,
            y: y,
            label: row[j],
            filled: 0,
            period: i,
            col: j
          });
          fillOrder.push(idx);
          idx++;
        }
      }
    }
    
    // Σχεδίαση βελών μεταξύ δύο σημείων
    function drawArrow(x1, y1, x2, y2) {
      let angle = atan2(y2 - y1, x2 - x1);
      // Σχεδίαση γραμμής
      line(x1, y1, x2, y2);
      // Σχεδίαση κεφαλής βέλους
      push();
      translate(x2, y2);
      rotate(angle);
      let arrowSize = 7;
      triangle(0, 0, -arrowSize, arrowSize/2, -arrowSize, -arrowSize/2);
      pop();
    }
    
    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      textSize(16);
      calculatePositions();
      noLoop();
    }
    
    function draw() {
      background(255);
      textAlign(CENTER, CENTER);
      
      // Σχεδίαση βελών σύμφωνα με τη σειρά συμπλήρωσης
      stroke(200, 0, 0);
      strokeWeight(2);
      for (let i = 0; i < fillOrder.length - 1; i++) {
        let idx1 = fillOrder[i];
        let idx2 = fillOrder[i + 1];
        let pos1 = positions[idx1];
        let pos2 = positions[idx2];
        drawArrow(pos1.x, pos1.y, pos2.x, pos2.y);
      }
      
      // Σχεδίαση των κουτιών για κάθε orbital
      noStroke();
      for (let pos of positions) {
        fill(220);
        rectMode(CENTER);
        rect(pos.x, pos.y, boxWidth, boxHeight);
        fill(0);
        text(pos.label + " (" + pos.filled + ")", pos.x, pos.y);
      }
    }
    
    // Συνάρτηση δόμησης (συμπλήρωσης) σύμφωνα με τον ατομικό αριθμό
    function startFilling() {
      // Επαναφορά των τιμών συμπλήρωσης
      for (let pos of positions) {
        pos.filled = 0;
      }
      let atomicNumber = parseInt(document.getElementById("atomicNumber").value);
      let remaining = atomicNumber;
      // Συμπλήρωση σύμφωνα με τη σειρά fillOrder
      for (let i = 0; i < fillOrder.length; i++) {
        let idx = fillOrder[i];
        let orbital = positions[idx];
        let orbType = orbital.label.slice(-1); // λαμβάνουμε τον τύπο: s, p, d, ή f
        let capacity = maxElectrons[orbType] || 2;
        let fillAmount = min(remaining, capacity);
        orbital.filled = fillAmount;
        remaining -= fillAmount;
        if (remaining <= 0) break;
      }
      redraw();
    }
  </script>
</body>
</html>
