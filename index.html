<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Κανόνας Aufbau</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { 
      text-align: center; 
      font-family: Verdana, sans-serif; 
      background-color: #f0f8ff;
    }
    canvas { 
      display: block; 
      margin: 20px auto; 
      border: 2px solid #4CAF50;
      border-radius: 10px;
      margin-left: 100px; /* Αριστερό περιθώριο 100px */
    }
    button { 
      margin: 10px; 
      padding: 10px 20px; 
      background-color: #4CAF50; 
      color: white; 
      border: none; 
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    #infoTable {
      margin: 20px auto;
      border-collapse: collapse;
      width: 420px; /* Αλλαγή πλάτους σε 420px */
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      background-color: white;
    }
    #infoTable th, #infoTable td {
      border: 2px solid #4CAF50;
      padding: 8px;
      text-align: center;
    }
    #infoTable th {
      background-color: #4CAF50;
      color: white;
      font-size: 14px;
    }
    #infoTable td {
      font-size: 12px;
    }
    .element-symbol {
      font-size: 24px;
      font-weight: bold;
      color: darkgreen;
      margin-right: 10px;
    }
    .element-symbol::before {
      content: attr(data-z);
      font-size: 14px;
      color: red;
      vertical-align: baseline;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <h1 style="color: #2E8B57;">Κανόνας Aufbau <span id="elementSymbol" class="element-symbol" data-z=""></span></h1>
  <div>
    <label for="atomicNumber" style="font-size: 16px;">Z:</label>
    <input type="number" id="atomicNumber" min="1" max="118" value="1" style="padding: 5px;">
    <button onclick="startFilling()">Έναρξη</button>
    <button onclick="resetDiagram()">Reset</button>
  </div>

  <table id="infoTable">
    <tr>
      <th colspan="2">Περίοδος: <span id="periodValue">-</span> | Ομάδα: <span id="groupValue">-</span></th>
    </tr>
    <tr>
      <td><strong>Αρχική Διαμόρφωση</strong></td>
      <td id="initialConfig">-</td>
    </tr>
    <tr>
      <td><strong>Τελική Διαμόρφωση</strong></td>
      <td id="finalConfig">-</td>
    </tr>
  </table>

  <table id="fillingOrderTable">
    <tr>
      <th>Συμπλήρωση</th>
    </tr>
    <tr>
      <td id="fillingOrder">-</td>
    </tr>
  </table>

  <table id="sortedOrderTable">
    <tr>
      <th>Ταξινόμηση</th>
    </tr>
    <tr>
      <td id="sortedOrder">-</td>
    </tr>
  </table>

  <script>
    const periods = [
      { label: "K", orbitals: ["1s"] },
      { label: "L", orbitals: ["2s", "2p"] },
      { label: "M", orbitals: ["3s", "3p", "3d"] },
      { label: "N", orbitals: ["4s", "4p", "4d", "4f"] },
      { label: "O", orbitals: ["5s", "5p", "5d", "5f"] },
      { label: "P", orbitals: ["6s", "6p", "6d"] },
      { label: "Q", orbitals: ["7s", "7p"] }
    ];

    const maxElectrons = { "s": 2, "p": 6, "d": 10, "f": 14 };
    const boxWidth = 60, boxHeight = 40, verticalSpacing = 45;
    const horizontalGap = 5;
    const canvasWidth = 420; // Αλλαγή πλάτους καμβά σε 420px
    const canvasHeight = 400; // Μείωση του πλάτους του καμβά
    const leftMargin = 100; // Αριστερό περιθώριο 100px
    const periodLabelWidth = 50;
    const fillOrder = [0, 1, 2, 3, 4, 6, 5, 7, 10, 8, 11, 14, 9, 12, 15, 17, 13, 16, 18];
    const exceptions = {
      24: { from: "4s", to: "3d", amount: 1 },  // Cr
      29: { from: "4s", to: "3d", amount: 1 },  // Cu
      47: { from: "5s", to: "4d", amount: 1 },  // Ag
      79: { from: "6s", to: "5d", amount: 1 }   // Au
    };

    let positions = [];
    let columnColors = [];
    let electronCounter = 0;

    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      textSize(12);
      textFont("Verdana");
      initColumnColors();
      calculatePositions();
      noLoop();
    }

    function draw() {
      background(255);
      drawPeriodLabels();
      drawOrbitals();
      drawArrows();
    }

    function initColumnColors() {
      columnColors = [
        color("#FFCDD2"), // s
        color("#C8E6C9"), // p
        color("#BBDEFB"), // d
        color("#FFF9C4")  // f
      ];
    }

    function calculatePositions() {
      positions = [];
      let startY = 50;
      for (let i = 0; i < periods.length; i++) {
        let rowOrbitals = periods[i].orbitals;
        let startX = leftMargin + periodLabelWidth;
        let y = startY + i * verticalSpacing;
        for (let j = 0; j < rowOrbitals.length; j++) {
          let x = startX + j * (boxWidth + horizontalGap);
          positions.push({ 
            x: x, y: y, 
            label: rowOrbitals[j],
            type: rowOrbitals[j].slice(-1),
            filled: 0,
            col: j,
            isGray: false,
            actualElectrons: 0
          });
        }
      }
    }

    function drawPeriodLabels() {
      textAlign(RIGHT, CENTER);
      fill(0);
      textSize(14);
      textStyle(BOLD);

      // Υπολογισμός ηλεκτρονίων ανά περίοδο
      const periodElectrons = new Array(periods.length).fill(0);
      positions.forEach(pos => {
        const periodIndex = periods.findIndex(p => p.orbitals.includes(pos.label));
        if (periodIndex !== -1) periodElectrons[periodIndex] += pos.actualElectrons;
      });

      for (let i = 0; i < periods.length; i++) {
        let y = 50 + i * verticalSpacing;
        const electrons = periodElectrons[i];
        text(`${periods[i].label}${electrons > 0 ? ` (${electrons})` : ''}`, leftMargin - 10, y + 17); // Κατέβασμα των ονομάτων των στιβάδων κατά 2px ακόμα
      }
      textStyle(NORMAL);
    }

    function drawOrbitals() {
      noStroke();
      textAlign(CENTER, CENTER);
      positions.forEach(pos => {
        fill(pos.isGray ? 200 : columnColors[pos.col]);
        rect(pos.x, pos.y, boxWidth, boxHeight);

        // Κύριο label
        fill(0);
        text(pos.label, pos.x + boxWidth/2, pos.y + boxHeight/2); // Επαναφορά των συμβόλων στην αρχική θέση

        // Εκθέτης (μαύρος σε γκρί ορθογώνια)
        if(pos.actualElectrons > 0) {
          textSize(14);
          textStyle(BOLD); // Κάνουμε τους εκθέτες έντονους
          fill(pos.isGray ? 0 : {
            's': color(255,0,0),
            'p': color(0,100,0),
            'd': color(0,0,255),
            'f': color(255,165,0)
          }[pos.type]);
          text(numberToExponent(pos.actualElectrons), pos.x + boxWidth - 15, pos.y + 10); // Επαναφορά των εκθετών στην αρχική θέση
          textStyle(NORMAL); // Επαναφορά του κανονικού στυλ
        }
      });
    }

    function drawArrows() {
      // Γκρίζα βέλη (θεωρητική σειρά)
      stroke(150);
      strokeWeight(2);
      drawingContext.setLineDash([5,5]);
      for(let i=0; i<fillOrder.length-1; i++) {
        let from = positions[fillOrder[i]];
        let to = positions[fillOrder[i+1]];
        if (to.y > from.y) {
          drawArrow(
            from.x + boxWidth,
            from.y + 10,
            to.x + boxWidth,
            to.y + 10
          );
        }
      }

      // Κόκκινα βέλη (πραγματική συμπλήρωση)
      stroke(255,0,0);
      drawingContext.setLineDash([]);
      let lastFilledIndex = -1;
      for (let i = fillOrder.length - 1; i >= 0; i--) {
        let idx = fillOrder[i];
        if (positions[idx].filled > 0) {
          lastFilledIndex = i;
          break;
        }
      }
      for (let i = 0; i < lastFilledIndex; i++) {
        let from = positions[fillOrder[i]];
        let to = positions[fillOrder[i+1]];
        if (to.y > from.y) {
          drawArrow(
            from.x + boxWidth,
            from.y + 10,
            to.x + boxWidth,
            to.y + 10
          );
        }
      }
    }

    function drawArrow(x1, y1, x2, y2) {
      line(x1, y1, x2, y2);
      let angle = atan2(y2 - y1, x2 - x1);
      push();
      translate(x2, y2);
      rotate(angle);
      let arrowSize = 7;
      triangle(-arrowSize, arrowSize / 2, -arrowSize, -arrowSize / 2, 0, 0);
      pop();
    }

    function startFilling() {
      resetDiagram();
      const Z = parseInt(document.getElementById("atomicNumber").value);
      electronCounter = Z;

      // Κανονικό γέμισμα (Aufbau)
      fillOrder.forEach(idx => {
        const orb = positions[idx];
        const capacity = maxElectrons[orb.type];
        const fill = Math.min(electronCounter, capacity);
        orb.filled = fill;
        electronCounter -= fill;
      });

      // Αντιγραφή για αρχική διαμόρφωση
      positions.forEach(p => p.actualElectrons = p.filled);

      // Εφαρμογή εξαιρέσεων
      if(exceptions[Z]) {
        const {from, to, amount} = exceptions[Z];
        const fromOrb = positions.find(p => p.label === from);
        const toOrb = positions.find(p => p.label === to);
        if(fromOrb && toOrb) {
          fromOrb.actualElectrons -= amount;
          toOrb.actualElectrons += amount;
        }
      }

      // Γκρίζα ορθογώνια εξωτερικής στιβάδας
      markOuterShell();
      updateDisplay(Z);
      redraw();
    }

    function markOuterShell() {
      const filled = positions.filter(p => p.actualElectrons > 0);
      const maxPeriod = Math.max(...filled.map(p => parseInt(p.label)));
      const lastOrbType = filled[filled.length-1].type;

      positions.forEach(pos => {
        const currentPeriod = parseInt(pos.label);
        pos.isGray = (currentPeriod === maxPeriod) && 
                     ((lastOrbType === 'p' && (pos.type === 's' || pos.type === 'p')) ||
                      (lastOrbType === 's' && pos.type === 's'));
      });
    }

    function numberToExponent(num) {
      const exponents = ['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹'];
      return num.toString().split('').map(d => exponents[d]).join('');
    }

    function updateDisplay(Z) {
      // Αρχική διαμόρφωση
      const initial = fillOrder
        .map(idx => positions[idx])
        .filter(p => p.filled > 0)
        .map(p => `${p.label}${numberToExponent(p.filled)}`);

      // Τελική διαμόρφωση
      const final = positions
        .filter(p => p.actualElectrons > 0)
        .sort((a,b) => {
          const aN = parseInt(a.label);
          const bN = parseInt(b.label);
          if (aN !== bN) return aN - bN;
          return a.type.localeCompare(b.type);
        })
        .map(p => `${p.label}${numberToExponent(p.actualElectrons)}`);

      document.getElementById("initialConfig").textContent = initial.join(" ");
      document.getElementById("finalConfig").textContent = final.join(" ");

      // Εμφάνιση της σειράς συμπλήρωσης και της ταξινόμησης
      document.getElementById("fillingOrder").textContent = initial.join(" ");
      document.getElementById("sortedOrder").textContent = final.join(" ");

      // Περίοδος και Ομάδα
      updatePeriodGroup();

      // Σύμβολο στοιχείου και δείκτης
      // document.getElementById("elementSymbol").textContent = elementSymbols[Z - 1];
      document.getElementById("elementSymbol").setAttribute("data-z", Z);
    }

    function updatePeriodGroup() {
      const filled = positions.filter(p => p.actualElectrons > 0);
      const valence = filled.filter(p => parseInt(p.label) === Math.max(...filled.map(p => parseInt(p.label))));

      // Περίοδος
      const period = Math.max(...filled.map(p => parseInt(p.label)));
      document.getElementById("periodValue").textContent = period;

      // Ομάδα
      let group = predictGroup(valence);
      document.getElementById("groupValue").textContent = group;
    }

    function predictGroup(valence) {
      let sElectrons = 0;
      let pElectrons = 0;
      let dElectrons = 0;
      let fElectrons = 0;

      valence.forEach(orbital => {
        if (orbital.type === 's') sElectrons += orbital.actualElectrons;
        if (orbital.type === 'p') pElectrons += orbital.actualElectrons;
        if (orbital.type === 'd') dElectrons += orbital.actualElectrons;
        if (orbital.type === 'f') fElectrons += orbital.actualElectrons;
      });

      let group = '-';
      if (pElectrons > 0) {
        group = `${toRoman(sElectrons + pElectrons)}A ή ${sElectrons + pElectrons + 10}`;
      } else if (dElectrons > 0) {
        group = `${toRoman(dElectrons)}B ή ${dElectrons + (dElectrons >= 10 ? 1 : 0)}`;
      } else if (fElectrons > 0) {
        group = `${toRoman(fElectrons)}B ή ${fElectrons + (fElectrons >= 10 ? 1 : 0)}`;
      } else {
        group = `${toRoman(sElectrons)}A ή ${sElectrons}`;
      }

      return group;
    }

    function toRoman(num) {
      const roman = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
      let str = '';
      for (let i of Object.keys(roman)) {
        let q = Math.floor(num / roman[i]);
        num -= q * roman[i];
        str += i.repeat(q);
      }
      return str;
    }

    function resetDiagram() {
      positions.forEach(p => {
        p.filled = 0;
        p.actualElectrons = 0;
        p.isGray = false;
      });
      document.getElementById("periodValue").textContent = '-';
      document.get<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Κανόνας Aufbau</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { 
      text-align: center; 
      font-family: Verdana, sans-serif; 
      background-color: #f0f8ff;
    }
    canvas { 
      display: block; 
      margin: 20px auto; 
      border: 2px solid #4CAF50;
      border-radius: 10px;
      margin-left: 100px; /* Αριστερό περιθώριο 100px */
    }
    button { 
      margin: 10px; 
      padding: 10px 20px; 
      background-color: #4CAF50; 
      color: white; 
      border: none; 
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background-color: #45a049;
    }
    #infoTable {
      margin: 20px auto;
      border-collapse: collapse;
      width: 420px; /* Αλλαγή πλάτους σε 420px */
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      background-color: white;
    }
    #infoTable th, #infoTable td {
      border: 2px solid #4CAF50;
      padding: 8px;
      text-align: center;
    }
    #infoTable th {
      background-color: #4CAF50;
      color: white;
      font-size: 14px;
    }
    #infoTable td {
      font-size: 12px;
    }
    .element-symbol {
      font-size: 24px;
      font-weight: bold;
      color: darkgreen;
      margin-right: 10px;
    }
    .element-symbol::before {
      content: attr(data-z);
      font-size: 14px;
      color: red;
      vertical-align: baseline;
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <h1 style="color: #2E8B57;">Κανόνας Aufbau <span id="elementSymbol" class="element-symbol" data-z=""></span></h1>
  <div>
    <label for="atomicNumber" style="font-size: 16px;">Z:</label>
    <input type="number" id="atomicNumber" min="1" max="118" value="1" style="padding: 5px;">
    <button onclick="startFilling()">Έναρξη</button>
    <button onclick="resetDiagram()">Reset</button>
  </div>

  <table id="infoTable">
    <tr>
      <th colspan="2">Περίοδος: <span id="periodValue">-</span> | Ομάδα: <span id="groupValue">-</span></th>
    </tr>
    <tr>
      <td><strong>Αρχική Διαμόρφωση</strong></td>
      <td id="initialConfig">-</td>
    </tr>
    <tr>
      <td><strong>Τελική Διαμόρφωση</strong></td>
      <td id="finalConfig">-</td>
    </tr>
  </table>

  <table id="fillingOrderTable">
    <tr>
      <th>Συμπλήρωση</th>
    </tr>
    <tr>
      <td id="fillingOrder">-</td>
    </tr>
  </table>

  <table id="sortedOrderTable">
    <tr>
      <th>Ταξινόμηση</th>
    </tr>
    <tr>
      <td id="sortedOrder">-</td>
    </tr>
  </table>

  <script>
    const periods = [
      { label: "K", orbitals: ["1s"] },
      { label: "L", orbitals: ["2s", "2p"] },
      { label: "M", orbitals: ["3s", "3p", "3d"] },
      { label: "N", orbitals: ["4s", "4p", "4d", "4f"] },
      { label: "O", orbitals: ["5s", "5p", "5d", "5f"] },
      { label: "P", orbitals: ["6s", "6p", "6d"] },
      { label: "Q", orbitals: ["7s", "7p"] }
    ];

    const maxElectrons = { "s": 2, "p": 6, "d": 10, "f": 14 };
    const boxWidth = 60, boxHeight = 40, verticalSpacing = 45;
    const horizontalGap = 5;
    const canvasWidth = 420; // Αλλαγή πλάτους καμβά σε 420px
    const canvasHeight = 400; // Μείωση του πλάτους του καμβά
    const leftMargin = 100; // Αριστερό περιθώριο 100px
    const periodLabelWidth = 50;
    const fillOrder = [0, 1, 2, 3, 4, 6, 5, 7, 10, 8, 11, 14, 9, 12, 15, 17, 13, 16, 18];
    const exceptions = {
      24: { from: "4s", to: "3d", amount: 1 },  // Cr
      29: { from: "4s", to: "3d", amount: 1 },  // Cu
      47: { from: "5s", to: "4d", amount: 1 },  // Ag
      79: { from: "6s", to: "5d", amount: 1 }   // Au
    };

    let positions = [];
    let columnColors = [];
    let electronCounter = 0;

    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      textSize(12);
      textFont("Verdana");
      initColumnColors();
      calculatePositions();
      noLoop();
    }

    function draw() {
      background(255);
      drawPeriodLabels();
      drawOrbitals();
      drawArrows();
    }

    function initColumnColors() {
      columnColors = [
        color("#FFCDD2"), // s
        color("#C8E6C9"), // p
        color("#BBDEFB"), // d
        color("#FFF9C4")  // f
      ];
    }

    function calculatePositions() {
      positions = [];
      let startY = 50;
      for (let i = 0; i < periods.length; i++) {
        let rowOrbitals = periods[i].orbitals;
        let startX = leftMargin + periodLabelWidth;
        let y = startY + i * verticalSpacing;
        for (let j = 0; j < rowOrbitals.length; j++) {
          let x = startX + j * (boxWidth + horizontalGap);
          positions.push({ 
            x: x, y: y, 
            label: rowOrbitals[j],
            type: rowOrbitals[j].slice(-1),
            filled: 0,
            col: j,
            isGray: false,
            actualElectrons: 0
          });
        }
      }
    }

    function drawPeriodLabels() {
      textAlign(RIGHT, CENTER);
      fill(0);
      textSize(14);
      textStyle(BOLD);

      // Υπολογισμός ηλεκτρονίων ανά περίοδο
      const periodElectrons = new Array(periods.length).fill(0);
      positions.forEach(pos => {
        const periodIndex = periods.findIndex(p => p.orbitals.includes(pos.label));
        if (periodIndex !== -1) periodElectrons[periodIndex] += pos.actualElectrons;
      });

      for (let i = 0; i < periods.length; i++) {
        let y = 50 + i * verticalSpacing;
        const electrons = periodElectrons[i];
        text(`${periods[i].label}${electrons > 0 ? ` (${electrons})` : ''}`, leftMargin - 10, y + 17); // Κατέβασμα των ονομάτων των στιβάδων κατά 2px ακόμα
      }
      textStyle(NORMAL);
    }

    function drawOrbitals() {
      noStroke();
      textAlign(CENTER, CENTER);
      positions.forEach(pos => {
        fill(pos.isGray ? 200 : columnColors[pos.col]);
        rect(pos.x, pos.y, boxWidth, boxHeight);

        // Κύριο label
        fill(0);
        text(pos.label, pos.x + boxWidth/2, pos.y + boxHeight/2); // Επαναφορά των συμβόλων στην αρχική θέση

        // Εκθέτης (μαύρος σε γκρί ορθογώνια)
        if(pos.actualElectrons > 0) {
          textSize(14);
          textStyle(BOLD); // Κάνουμε τους εκθέτες έντονους
          fill(pos.isGray ? 0 : {
            's': color(255,0,0),
            'p': color(0,100,0),
            'd': color(0,0,255),
            'f': color(255,165,0)
          }[pos.type]);
          text(numberToExponent(pos.actualElectrons), pos.x + boxWidth - 15, pos.y + 10); // Επαναφορά των εκθετών στην αρχική θέση
          textStyle(NORMAL); // Επαναφορά του κανονικού στυλ
        }
      });
    }

    function drawArrows() {
      // Γκρίζα βέλη (θεωρητική σειρά)
      stroke(150);
      strokeWeight(2);
      drawingContext.setLineDash([5,5]);
      for(let i=0; i<fillOrder.length-1; i++) {
        let from = positions[fillOrder[i]];
        let to = positions[fillOrder[i+1]];
        if (to.y > from.y) {
          drawArrow(
            from.x + boxWidth,
            from.y + 10,
            to.x + boxWidth,
            to.y + 10
          );
        }
      }

      // Κόκκινα βέλη (πραγματική συμπλήρωση)
      stroke(255,0,0);
      drawingContext.setLineDash([]);
      let lastFilledIndex = -1;
      for (let i = fillOrder.length - 1; i >= 0; i--) {
        let idx = fillOrder[i];
        if (positions[idx].filled > 0) {
          lastFilledIndex = i;
          break;
        }
      }
      for (let i = 0; i < lastFilledIndex; i++) {
        let from = positions[fillOrder[i]];
        let to = positions[fillOrder[i+1]];
        if (to.y > from.y) {
          drawArrow(
            from.x + boxWidth,
            from.y + 10,
            to.x + boxWidth,
            to.y + 10
          );
        }
      }
    }

    function drawArrow(x1, y1, x2, y2) {
      line(x1, y1, x2, y2);
      let angle = atan2(y2 - y1, x2 - x1);
      push();
      translate(x2, y2);
      rotate(angle);
      let arrowSize = 7;
      triangle(-arrowSize, arrowSize / 2, -arrowSize, -arrowSize / 2, 0, 0);
      pop();
    }

    function startFilling() {
      resetDiagram();
      const Z = parseInt(document.getElementById("atomicNumber").value);
      electronCounter = Z;

      // Κανονικό γέμισμα (Aufbau)
      fillOrder.forEach(idx => {
        const orb = positions[idx];
        const capacity = maxElectrons[orb.type];
        const fill = Math.min(electronCounter, capacity);
        orb.filled = fill;
        electronCounter -= fill;
      });

      // Αντιγραφή για αρχική διαμόρφωση
      positions.forEach(p => p.actualElectrons = p.filled);

      // Εφαρμογή εξαιρέσεων
      if(exceptions[Z]) {
        const {from, to, amount} = exceptions[Z];
        const fromOrb = positions.find(p => p.label === from);
        const toOrb = positions.find(p => p.label === to);
        if(fromOrb && toOrb) {
          fromOrb.actualElectrons -= amount;
          toOrb.actualElectrons += amount;
        }
      }

      // Γκρίζα ορθογώνια εξωτερικής στιβάδας
      markOuterShell();
      updateDisplay(Z);
      redraw();
    }

    function markOuterShell() {
      const filled = positions.filter(p => p.actualElectrons > 0);
      const maxPeriod = Math.max(...filled.map(p => parseInt(p.label)));
      const lastOrbType = filled[filled.length-1].type;

      positions.forEach(pos => {
        const currentPeriod = parseInt(pos.label);
        pos.isGray = (currentPeriod === maxPeriod) && 
                     ((lastOrbType === 'p' && (pos.type === 's' || pos.type === 'p')) ||
                      (lastOrbType === 's' && pos.type === 's'));
      });
    }

    function numberToExponent(num) {
      const exponents = ['⁰','¹','²','³','⁴','⁵','⁶','⁷','⁸','⁹'];
      return num.toString().split('').map(d => exponents[d]).join('');
    }

    function updateDisplay(Z) {
      // Αρχική διαμόρφωση
      const initial = fillOrder
        .map(idx => positions[idx])
        .filter(p => p.filled > 0)
        .map(p => `${p.label}${numberToExponent(p.filled)}`);

      // Τελική διαμόρφωση
      const final = positions
        .filter(p => p.actualElectrons > 0)
        .sort((a,b) => {
          const aN = parseInt(a.label);
          const bN = parseInt(b.label);
          if (aN !== bN) return aN - bN;
          return a.type.localeCompare(b.type);
        })
        .map(p => `${p.label}${numberToExponent(p.actualElectrons)}`);

      document.getElementById("initialConfig").textContent = initial.join(" ");
      document.getElementById("finalConfig").textContent = final.join(" ");

      // Εμφάνιση της σειράς συμπλήρωσης και της ταξινόμησης
      document.getElementById("fillingOrder").textContent = initial.join(" ");
      document.getElementById("sortedOrder").textContent = final.join(" ");

      // Περίοδος και Ομάδα
      updatePeriodGroup();

      // Σύμβολο στοιχείου και δείκτης
      // document.getElementById("elementSymbol").textContent = elementSymbols[Z - 1];
      document.getElementById("elementSymbol").setAttribute("data-z", Z);
    }

    function updatePeriodGroup() {
      const filled = positions.filter(p => p.actualElectrons > 0);
      const valence = filled.filter(p => parseInt(p.label) === Math.max(...filled.map(p => parseInt(p.label))));

      // Περίοδος
      const period = Math.max(...filled.map(p => parseInt(p.label)));
      document.getElementById("periodValue").textContent = period;

      // Ομάδα
      let group = predictGroup(valence);
      document.getElementById("groupValue").textContent = group;
    }

    function predictGroup(valence) {
      let sElectrons = 0;
      let pElectrons = 0;
      let dElectrons = 0;
      let fElectrons = 0;

      valence.forEach(orbital => {
        if (orbital.type === 's') sElectrons += orbital.actualElectrons;
        if (orbital.type === 'p') pElectrons += orbital.actualElectrons;
        if (orbital.type === 'd') dElectrons += orbital.actualElectrons;
        if (orbital.type === 'f') fElectrons += orbital.actualElectrons;
      });

      let group = '-';
      if (pElectrons > 0) {
        group = `${toRoman(sElectrons + pElectrons)}A ή ${sElectrons + pElectrons + 10}`;
      } else if (dElectrons > 0) {
        group = `${toRoman(dElectrons)}B ή ${dElectrons + (dElectrons >= 10 ? 1 : 0)}`;
      } else if (fElectrons > 0) {
        group = `${toRoman(fElectrons)}B ή ${fElectrons + (fElectrons >= 10 ? 1 : 0)}`;
      } else {
        group = `${toRoman(sElectrons)}A ή ${sElectrons}`;
      }

      return group;
    }

    function toRoman(num) {
      const roman = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
      let str = '';
      for (let i of Object.keys(roman)) {
        let q = Math.floor(num / roman[i]);
        num -= q * roman[i];
        str += i.repeat(q);
      }
      return str;
    }

    function resetDiagram() {
      positions.forEach(p => {
        p.filled = 0;
        p.actualElectrons = 0;
        p.isGray = false;
      });
      document.getElementById("periodValue").textContent = '-';
      document.get
