<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aufbau Διάγραμμα</title>
  <!-- Χρήση της βιβλιοθήκης p5.js για γραφική απεικόνιση -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { text-align: center; font-family: Verdana, sans-serif; }
    canvas { display: block; margin: auto; }
  </style>
</head>
<body>
  <h1>Aufbau Διάγραμμα</h1>
  <label for="atomicNumber">Ατομικός Αριθμός:</label>
  <input type="number" id="atomicNumber" min="1" max="118" value="1">
  <button onclick="startFilling()">Ξεκίνα Δόμηση</button>
  
  <script>
    /* 
      Ορισμός των περιόδων σύμφωνα με το ζητούμενο σχήμα:
      
        K:  1s
        L:  2s   2p
        M:  3s   3p   3d
        N:  4s   4p   4d   4f
        O:  5s   5p   5d   5f
        P:  6s   6p   6d
        Q:  7s   7p
    */
    let periods = [
      { label: "K", orbitals: ["1s"] },
      { label: "L", orbitals: ["2s", "2p"] },
      { label: "M", orbitals: ["3s", "3p", "3d"] },
      { label: "N", orbitals: ["4s", "4p", "4d", "4f"] },
      { label: "O", orbitals: ["5s", "5p", "5d", "5f"] },
      { label: "P", orbitals: ["6s", "6p", "6d"] },
      { label: "Q", orbitals: ["7s", "7p"] }
    ];
    
    // Μέγιστοι αριθμοί ηλεκτρονίων ανά orbital
    let maxElectrons = { "s": 2, "p": 6, "d": 10, "f": 14 };
    
    // Σταθερές σχεδίασης
    let boxWidth = 60, boxHeight = 40, verticalSpacing = 70;
    let canvasWidth = 800, canvasHeight = 500;
    let leftMargin = 120;  // Σταθερή αριστερή στοίχιση
    
    // Array για αποθήκευση των δεδομένων κάθε orbital (σε επίπεδη δομή)
    // Κάθε στοιχείο έχει: x, y, label, filled, col (index μέσα στην περίοδο)
    let positions = [];
    /* 
      Διάταξη:
      Row K: index 0           → "1s"
      Row L: index 1,2         → "2s", "2p"
      Row M: index 3,4,5       → "3s", "3p", "3d"
      Row N: index 6,7,8,9     → "4s", "4p", "4d", "4f"
      Row O: index 10,11,12,13  → "5s", "5p", "5d", "5f"
      Row P: index 14,15,16     → "6s", "6p", "6d"
      Row Q: index 17,18        → "7s", "7p"
    */
    
    // Η σειρά συμπλήρωσης (Aufbau order) (ως indices στα positions):
    // 1s, 2s, 2p, 3s, 3p, 4s, 3d, 4p, 5s, 4d, 5p, 6s, 4f, 5d, 6p, 7s, 5f, 6d, 7p
    let fillOrder = [0, 1, 2, 3, 4, 6, 5, 7, 10, 8, 11, 14, 9, 12, 15, 17, 13, 16, 18];
    
    // Ορισμός διαφορετικών pastel χρωμάτων για κάθε στήλη
    let columnColors = [];
    function initColumnColors() {
      columnColors = [
        color("#FFCDD2"), // στήλη 0
        color("#C8E6C9"), // στήλη 1
        color("#BBDEFB"), // στήλη 2
        color("#FFF9C4"), // στήλη 3
        color("#D1C4E9")  // στήλη 4 (αν χρειαστεί)
      ];
    }
    
    // Υπολογισμός θέσεων: Κάθε περίοδος στοιχίζεται αριστερά (ξεκινά από leftMargin).
    function calculatePositions() {
      positions = [];
      let startY = 50;
      for (let i = 0; i < periods.length; i++) {
        let rowOrbitals = periods[i].orbitals;
        let gap = 10;
        let startX = leftMargin; // Σταθερή αριστερή στοίχιση
        let y = startY + i * verticalSpacing;
        for (let j = 0; j < rowOrbitals.length; j++) {
          let x = startX + j * (boxWidth + gap);
          positions.push({ x: x, y: y, label: rowOrbitals[j], filled: 0, col: j });
        }
      }
    }
    
    // Σχεδίαση βελών μόνο για τα orbitals που έχουν συμπληρωθεί.
    // Βρέσε το τελευταίο index στο fillOrder για το οποίο έχει γίνει συμπλήρωση (δηλαδή, filled > 0)
    function drawArrows() {
      let arrowColor = color(200, 230, 255); // απαλό γαλάζιο
      stroke(arrowColor);
      strokeWeight(2);
      
      // Βρες το όριο (μέγιστο n) στο fillOrder όπου τα orbitals είναι γεμάτα (ή τουλάχιστον έχουν κάποια συμπλήρωση)
      let lastFilled = -1;
      for (let i = 0; i < fillOrder.length; i++) {
        let pos = positions[fillOrder[i]];
        if (pos.filled > 0) {
          lastFilled = i;
        } else {
          break;
        }
      }
      // Αν έχουμε τουλάχιστον δύο γεμάτα, σχεδίασε τις γραμμές μεταξύ τους
      for (let i = 0; i < lastFilled; i++) {
        let idx1 = fillOrder[i];
        let idx2 = fillOrder[i+1];
        let pos1 = positions[idx1];
        let pos2 = positions[idx2];
        // Σχεδίασε το βέλος μόνο αν το επόμενο κουτί βρίσκεται χαμηλότερα
        if (pos2.y > pos1.y) {
          drawArrow(pos1.x, pos1.y, pos2.x, pos2.y);
        }
      }
   
