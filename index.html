<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Aufbau Διάγραμμα</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { text-align: center; font-family: Verdana, sans-serif; }
    canvas { display: block; margin: auto; }
    button { margin: 5px; }
  </style>
</head>
<body>
  <h1>Aufbau Διάγραμμα</h1>
  <label for="atomicNumber">Ατομικός Αριθμός:</label>
  <input type="number" id="atomicNumber" min="1" max="118" value="1">
  <button onclick="startFilling()">Ξεκίνα Δόμηση</button>
  <button onclick="resetDiagram()">Reset</button>  <!-- Νέο κουμπί Reset -->
  
  <script>
    let periods = [
      { label: "K", orbitals: ["1s"] },
      { label: "L", orbitals: ["2s", "2p"] },
      { label: "M", orbitals: ["3s", "3p", "3d"] },
      { label: "N", orbitals: ["4s", "4p", "4d", "4f"] },
      { label: "O", orbitals: ["5s", "5p", "5d", "5f"] },
      { label: "P", orbitals: ["6s", "6p", "6d"] },
      { label: "Q", orbitals: ["7s", "7p"] }
    ];
    
    let maxElectrons = { "s": 2, "p": 6, "d": 10, "f": 14 };
    
    let boxWidth = 60, boxHeight = 40, verticalSpacing = 45;  // Μειωμένη απόσταση ανάμεσα στις γραμμές
    let horizontalGap = 5;  // Μειωμένη απόσταση ανάμεσα στις στήλες
    let canvasWidth = 800, canvasHeight = 500;
    let leftMargin = 120;  // Αριστερή στοίχιση για τα ονόματα των στιβάδων
    let periodLabelWidth = 50;  // Πλάτος για τα ονόματα των στιβάδων
    
    let positions = [];
    let fillOrder = [0, 1, 2, 3, 4, 6, 5, 7, 10, 8, 11, 14, 9, 12, 15, 17, 13, 16, 18];
    
    let columnColors = [];
    function initColumnColors() {
      columnColors = [
        color("#FFCDD2"), // στήλη 0
        color("#C8E6C9"), // στήλη 1
        color("#BBDEFB"), // στήλη 2
        color("#FFF9C4"), // στήλη 3
        color("#D1C4E9")  // στήλη 4
      ];
    }
    
    function calculatePositions() {
      positions = [];
      let startY = 50;
      for (let i = 0; i < periods.length; i++) {
        let rowOrbitals = periods[i].orbitals;
        let startX = leftMargin + periodLabelWidth;  // Αριστερή στοίχιση μετά τα ονόματα των στιβάδων
        let y = startY + i * verticalSpacing;
        for (let j = 0; j < rowOrbitals.length; j++) {
          let x = startX + j * (boxWidth + horizontalGap);  // Χρήση του νέου horizontalGap
          positions.push({ x: x, y: y, label: rowOrbitals[j], filled: 0, col: j });
        }
      }
    }
    
    function drawArrows() {
      // Σχεδίαση των γαλάζιων βελών (όλες οι πιθανές διαδρομές)
      let blueArrowColor = color(200, 230, 255);  // Γαλάζιο χρώμα για τα βέλα
      stroke(blueArrowColor);
      strokeWeight(2);
      for (let i = 0; i < fillOrder.length - 1; i++) {
        let idx1 = fillOrder[i];
        let idx2 = fillOrder[i+1];
        let pos1 = positions[idx1];
        let pos2 = positions[idx2];
        if (pos2.y > pos1.y) {
          // Offset για να ξεκινάει το βέλος 13 pixel κάτω από το κέντρο του πρώτου ορθογωνίου
          let startOffset = 13;
          // Offset για να καταλήγει το βέλος 13 pixel κάτω από το κέντρο του δεύτερου ορθογωνίου
          let endOffset = 13;
          
          let x1 = pos1.x;
          let y1 = pos1.y + startOffset;
          let x2 = pos2.x;
          let y2 = pos2.y + endOffset;
          
          drawArrow(x1, y1, x2, y2);
        }
      }
      
      // Σχεδίαση των κόκκινων βελών (μόνο μέχρι το σημείο συμπλήρωσης)
      let redArrowColor = color(255, 0, 0);  // Κόκκινο χρώμα για τα βέλα
      stroke(redArrowColor);
      strokeWeight(2);
      
      let lastFilledIndex = -1;
      for (let i = fillOrder.length - 1; i >= 0; i--) {
        let idx = fillOrder[i];
        if (positions[idx].filled > 0) {
          lastFilledIndex = i;
          break;
        }
      }
      
      for (let i = 0; i < lastFilledIndex; i++) {
        let idx1 = fillOrder[i];
        let idx2 = fillOrder[i+1];
        let pos1 = positions[idx1];
        let pos2 = positions[idx2];
        if (pos2.y > pos1.y) {
          let startOffset = 13;
          let endOffset = 13;
          let x1 = pos1.x;
          let y1 = pos1.y + startOffset;
          let x2 = pos2.x;
          let y2 = pos2.y + endOffset;
          
          drawArrow(x1, y1, x2, y2);
        }
      }
    }
    
    function drawArrow(x1, y1, x2, y2) {
      line(x1, y1, x2, y2);
      let angle = atan2(y2 - y1, x2 - x1);
      push();
      translate(x2, y2);
      rotate(angle);
      let arrowSize = 7;
      triangle(0, 0, -arrowSize, arrowSize/2, -arrowSize, -arrowSize/2);
      pop();
    }
    
    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      textSize(12);
      textFont("Verdana");
      initColumnColors();
      calculatePositions();
      noLoop();
    }
    
    function draw() {
      background(255);
      
      // Υπολογισμός του συνολικού αριθμού ηλεκτρονίων κάθε στιβάδας
      let periodElectrons = new Array(periods.length).fill(0);
      for (let pos of positions) {
        let periodIndex = periods.findIndex(p => p.orbitals.includes(pos.label));
        if (periodIndex !== -1) {
          periodElectrons[periodIndex] += pos.filled;
        }
      }
      
      // Σχεδίαση των ονομάτων των στιβάδων (K, L, M, ...) στην πρώτη στήλη
      textAlign(RIGHT, CENTER);
      fill(0);
      textSize(14);
      textStyle(BOLD);
      for (let i = 0; i < periods.length; i++) {
        let y = 50 + i * verticalSpacing;
        if (periodElectrons[i] > 0) {
          text(periods[i].label + " (" + periodElectrons[i] + ")", leftMargin - 10, y);
        } else {
          text(periods[i].label, leftMargin - 10, y);
        }
      }
      textStyle(NORMAL);
      textSize(12);
      
      // Σχεδίαση των τροχιακών (orbitals)
      noStroke();
      textAlign(CENTER, CENTER);
      for (let pos of positions) {
        let colIndex = pos.col;
        let colColor = columnColors[colIndex % columnColors.length];
        fill(colColor);
        rectMode(CENTER);
        rect(pos.x, pos.y, boxWidth, boxHeight);
        fill(0);
        
        // Εμφάνιση του label με εκθέτη αν ο αριθμός ηλεκτρονίων είναι > 0
        if (pos.filled > 0) {
          let label = pos.label;  // π.χ., "2p"
          let exponent = pos.filled;  // π.χ., 6
          let labelWidth = textWidth(label);
          text(label, pos.x - labelWidth / 4, pos.y);
          
          // Σχεδίαση του εκθέτη: για p orbitals, πράσινο σε μικρότερο μέγεθος
          textSize(10);
          textStyle(BOLD);
          if (label.endsWith("p")) {
            fill(0,128,0); // πράσινο για p orbitals
          } else {
            fill(255,0,0); // κόκκινο για τα υπόλοιπα (όπως ήταν αρχικά)\n          }\n          text(exponent, pos.x + labelWidth / 4, pos.y - 5);\n          fill(0);\n          textStyle(NORMAL);\n          textSize(12);\n        } else {\n          text(pos.label, pos.x, pos.y);\n        }\n      }\n      \n      // Σχεδίαση των βελών (πάνω από τα ορθογώνια)\n      drawArrows();\n    }\n    \n    function startFilling() {\n      for (let pos of positions) {\n        pos.filled = 0;\n      }\n      let atomicNumber = parseInt(document.getElementById(\"atomicNumber\").value);\n      let remaining = atomicNumber;\n      for (let i = 0; i < fillOrder.length; i++) {\n        let idx = fillOrder[i];\n        let orbital = positions[idx];\n        let orbType = orbital.label.slice(-1);\n        let capacity = maxElectrons[orbType] || 2;\n        let fillAmount = min(remaining, capacity);\n        orbital.filled = fillAmount;\n        remaining -= fillAmount;\n        if (remaining <= 0) break;\n      }\n      redraw();\n    }\n    \n    // Συνάρτηση reset\n    function resetDiagram() {\n      for (let pos of positions) {\n        pos.filled = 0;\n      }\n      document.getElementById(\"atomicNumber\").value = 1;\n      redraw();\n    }\n  </script>\n</body>\n</html>
