<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Κανόνας Aufbau</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { text-align: center; font-family: Verdana, sans-serif; }
    canvas { display: block; margin: auto; }
    button { margin: 5px; padding: 10px 20px; font-size: 14px; }
    #infoTable {
      margin-top: 20px;
      font-size: 14px;
      font-weight: normal;
      border-collapse: collapse;
      width: 50%;
      margin-left: auto;
      margin-right: auto;
    }
    #infoTable th, #infoTable td {
      border: 1px solid black;
      padding: 8px;
      text-align: center;
    }
    #infoTable th {
      background-color: #f2f2f2;
    }
    .instructions {
      font-size: 12px;
      color: #777;
    }
  </style>
</head>
<body>
  <h1>Κανόνας Aufbau</h1>
  <label for="atomicNumber">Z:</label>
  <input type="number" id="atomicNumber" min="1" max="118" value="1">
  <button onclick="startFilling()">Έναρξη</button>
  <button onclick="resetDiagram()">Reset</button>
  <div id="elementInfo"></div>
  <table id="infoTable">
    <tr>
      <td>Περίοδος</td>
      <td id="periodInfo"></td>
    </tr>
    <tr>
      <td>Ομάδα</td>
      <td id="groupInfo"></td>
    </tr>
    <tr>
      <td>Σύμβολο Στοιχείου</td>
      <td id="elementSymbol"></td>
    </tr>
    <tr>
      <td>Αρχική διαμόρφωση</td>
      <td id="initialConfigInfo"></td>
    </tr>
    <tr>
      <td>Τελική διαμόρφωση</td>
      <td id="electronConfigInfo"></td>
    </tr>
    <tr>
      <td colspan="2" class="instructions">
        Οδηγίες: Εισάγετε τον ατομικό αριθμό του στοιχείου και πατήστε "Έναρξη" για να δείτε την ηλεκτρονική διαμόρφωση και το διάγραμμα. Πατήστε "Reset" για να επαναφέρετε το διάγραμμα.
      </td>
    </tr>
  </table>
  <script>
    const periods = [
      { label: "K", orbitals: ["1s"] },
      { label: "L", orbitals: ["2s", "2p"] },
      { label: "M", orbitals: ["3s", "3p", "3d"] },
      { label: "N", orbitals: ["4s", "4p", "4d", "4f"] },
      { label: "O", orbitals: ["5s", "5p", "5d", "5f"] },
      { label: "P", orbitals: ["6s", "6p", "6d"] },
      { label: "Q", orbitals: ["7s", "7p"] }
    ];
    const maxElectrons = { "s": 2, "p": 6, "d": 10, "f": 14 };
    const boxWidth = 60, boxHeight = 40, verticalSpacing = 45;
    const horizontalGap = 5;
    const canvasWidth = 800, canvasHeight = 500;
    const leftMargin = 120;
    const periodLabelWidth = 50;
    const fillOrder = [0, 1, 2, 3, 4, 6, 5, 7, 10, 8, 11, 14, 9, 12, 15, 17, 13, 16, 18];
    let positions = [], columnColors = [], lastFilledS = null, lastFilledP = null, lastPeriod = -1;

    // Λίστα με τα σύμβολα των στοιχείων
    const elementSymbols = [
      "H", "He", "Li", "Be", "B", "C", "N", "O", "F", "Ne", "Na", "Mg", "Al", "Si", "P", "S", "Cl", "Ar",
      "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga", "Ge", "As", "Se", "Br", "Kr",
      "Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In", "Sn", "Sb", "Te", "I", "Xe",
      "Cs", "Ba", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu",
      "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn",
      "Fr", "Ra", "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr",
      "Rf", "Db", "Sg", "Bh", "Hs", "Mt", "Ds", "Rg", "Cn", "Nh", "Fl", "Mc", "Lv", "Ts", "Og"
    ];

    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      textSize(12);
      textFont("Verdana");
      initColumnColors();
      calculatePositions();
      noLoop();
    }

    function draw() {
      background(255);
      drawPeriodLabels();
      drawOrbitals();
      drawArrows();
    }

    function initColumnColors() {
      columnColors = [
        color("#FFCDD2"), color("#C8E6C9"), color("#BBDEFB"),
        color("#FFF9C4"), color("#D1C4E9")
      ];
    }

    function calculatePositions() {
      positions = [];
      let startY = 50;
      for (let i = 0; i < periods.length; i++) {
        let rowOrbitals = periods[i].orbitals;
        let startX = leftMargin + periodLabelWidth;
        let y = startY + i * verticalSpacing;
        for (let j = 0; j < rowOrbitals.length; j++) {
          let x = startX + j * (boxWidth + horizontalGap);
          positions.push({ x: x, y: y, label: rowOrbitals[j], filled: 0, col: j });
        }
      }
    }

    function drawPeriodLabels() {
      let periodElectrons = new Array(periods.length).fill(0);
      for (let pos of positions) {
        let periodIndex = periods.findIndex(p => p.orbitals.includes(pos.label));
        if (periodIndex !== -1) periodElectrons[periodIndex] += pos.filled;
      }
      textAlign(RIGHT, CENTER);
      fill(0);
      textSize(14);
      textStyle(BOLD);
      for (let i = 0; i < periods.length; i++) {
        let y = 50 + i * verticalSpacing;
        text(periods[i].label + (periodElectrons[i] > 0 ? " (" + periodElectrons[i] + ")" : ""), leftMargin - 10, y);
      }
      textStyle(NORMAL);
      textSize(12);
    }

    function drawOrbitals() {
      noStroke();
      textAlign(CENTER, CENTER);
      for (let pos of positions) {
        let colIndex = pos.col;
        let colColor = columnColors[colIndex % columnColors.length];
        if (pos.isGray) colColor = color(200);
        fill(colColor);
        rectMode(CENTER);
        rect(pos.x, pos.y, boxWidth, boxHeight);
        fill(0);
        if (pos.filled > 0) {
          let label = pos.label;
          let exponent = pos.filled;
          let labelWidth = textWidth(label);
          text(label, pos.x - labelWidth / 4, pos.y);
          textSize(10);
          textStyle(BOLD);
          if (pos.isGray) fill(0);
          else if (label.endsWith("s")) fill(255, 0, 0);
          else if (label.endsWith("p")) fill(0, 100, 0); // Σκούρο πράσινο για τα τροχιακά p
          else if (label.endsWith("d")) fill(0, 0, 255);
          else if (label.endsWith("f")) fill(255, 165, 0);
          text(exponent, pos.x + labelWidth / 4, pos.y - 8); // Υπερκείμενοι εκθέτες στο διάγραμμα
          fill(0);
          textStyle(NORMAL);
          textSize(12);
        } else {
          text(pos.label, pos.x, pos.y);
        }
      }
    }

    function drawArrows() {
      let grayArrowColor = color(150, 150, 150);
      stroke(grayArrowColor);
      strokeWeight(2);
      drawingContext.setLineDash([5, 5]);
      for (let i = 0; i < fillOrder.length - 1; i++) {
        let idx1 = fillOrder[i];
        let idx2 = fillOrder[i + 1];
        let pos1 = positions[idx1];
        let pos2 = positions[idx2];
        if (pos2.y > pos1.y) {
          let startOffset = 13;
          let endOffset = 13;
          let x1 = pos1.x + boxWidth / 2;
          let y1 = pos1.y - boxHeight / 2 + startOffset;
          let x2 = pos2.x + boxWidth / 2;
          let y2 = pos2.y - boxHeight / 2 + endOffset;
          drawArrow(x1, y1, x2, y2);
        }
      }
      drawingContext.setLineDash([]);
      let redArrowColor = color(255, 0, 0);
      stroke(redArrowColor);
      strokeWeight(2);
      let lastFilledIndex = -1;
      for (let i = fillOrder.length - 1; i >= 0; i--) {
        let idx = fillOrder[i];
        if (positions[idx].filled > 0) {
          lastFilledIndex = i;
          break;
        }
      }
      for (let i = 0; i < lastFilledIndex; i++) {
        let idx1 = fillOrder[i];
        let idx2 = fillOrder[i + 1];
        let pos1 = positions[idx1];
        let pos2 = positions[idx2];
        if (pos2.y > pos1.y) {
          let startOffset = 13;
          let endOffset = 13;
          let x1 = pos1.x + boxWidth / 2;
          let y1 = pos1.y - boxHeight / 2 + startOffset;
          let x2 = pos2.x + boxWidth / 2;
          let y2 = pos2.y - boxHeight / 2 + endOffset;
          drawArrow(x1, y1, x2, y2);
        }
      }
    }

    function drawArrow(x1, y1, x2, y2) {
      line(x1, y1, x2, y2);
      let angle = atan2(y2 - y1, x2 - x1);
      push();
      translate(x2, y2);
      rotate(angle);
      let arrowSize = 7;
      triangle(0, 0, -arrowSize, arrowSize / 2, -arrowSize, -arrowSize / 2);
      pop();
    }

    function startFilling() {
      for (let pos of positions) {
        pos.filled = 0;
        pos.isGray = false;
      }
      lastFilledS = null;
      lastFilledP = null;
      lastPeriod = -1;
      let atomicNumber = parseInt(document.getElementById("atomicNumber").value);
      let remaining = atomicNumber;
      let electronConfig = [];
      for (let i = 0; i < fillOrder.length; i++) {
        let idx = fillOrder[i];
        let orbital = positions[idx];
        let orbType = orbital.label.slice(-1);
        let periodNumber = parseInt(orbital.label.slice(0, -1));
        let capacity = maxElectrons[orbType] || 2;
        let fillAmount = Math.min(remaining, capacity);
        orbital.filled = fillAmount;
        remaining -= fillAmount;
        if (fillAmount > 0) {
          electronConfig.push(`${orbital.label}${fillAmount}`);
        }
        if (remaining <= 0) break;
      }
      document.getElementById("electronConfigInfo").innerText = electronConfig.join(", ");
      document.getElementById("elementSymbol").innerText = elementSymbols[atomicNumber - 1] || "Άγνωστο";
      
      let initialConfig = electronConfig.map(config => {
        let [orbital, count] = config.split(/(\d+)/);
        return `${orbital}<sup>${count}</sup>`;
      }).join(", ");
      document.getElementById("initialConfigInfo").innerHTML = initialConfig;

      let outermostPeriod = Math.max(...positions.filter(p => p.filled > 0).map(p => parseInt(p.label.slice(0, -1))));
      if (outermostPeriod !== -1) {
        let lastPeriodOrbitals = positions.filter(p => parseInt(p.label.slice(0, -1)) === outermostPeriod);
        lastFilledS = lastPeriodOrbitals.find(o => o.label.endsWith("s") && o.filled > 0);
        lastFilledP = lastPeriodOrbitals.find(o => o.label.endsWith("p") && o.filled > 0);
        if (lastFilledP) {
          positions.forEach(pos => {
            if (parseInt(pos.label.slice(0, -1)) === outermostPeriod && (pos.label.endsWith("s") || pos.label.endsWith("p"))) {
              pos.isGray = true;
            }
          });
        } else if (lastFilledS) {
          let pos = positions.find(p => p.label === lastFilledS.label);
          if (pos) pos.isGray = true;
        }
      }
      predictElementPosition(outermostPeriod, lastFilledS, lastFilledP);
      redraw();
    }

    function predictElementPosition(period, lastFilledS, lastFilledP) {
      let groupRoman = '';
      let groupNumber = 0;
      
      if (lastFilledP && lastFilledP.filled) {
        const group = lastFilledS.filled + lastFilledP.filled;
        groupRoman = toRoman(group) + 'A';
        groupNumber = 12 + lastFilledP.filled;
      } else if (lastFilledS && lastFilledS.filled) {
        groupRoman = toRoman(lastFilledS.filled) + 'A';
        groupNumber = lastFilledS.filled;
      }
      
      document.getElementById("periodInfo").innerText = period || '-';
      document.getElementById("groupInfo").innerText = `${groupRoman} ή ${groupNumber}`;
    }

    function toRoman(num) {
      const roman = { M: 1000, CM: 900, D: 500, CD: 400, C: 100, XC: 90, L: 50, XL: 40, X: 10, IX: 9, V: 5, IV: 4, I: 1 };
      let str = '';
      for (let i of Object.keys(roman)) {
        let q = Math.floor(num / roman[i]);
        num -= q * roman[i];
        str += i.repeat(q);
      }
      return str;
    }

    function resetDiagram() {
      for (let pos of positions) {
        pos.filled = 0;
        pos.isGray = false;
      }
      lastFilledS = null;
      lastFilledP = null;
      document.getElementById("atomicNumber").value = 1;
      document.getElementById("electronConfigInfo").innerText = '';
      document.getElementById("initialConfigInfo").innerText = '';
      document.getElementById("periodInfo").innerText = '';
      document.getElementById("groupInfo").innerText = '';
      document.getElementById("elementSymbol").innerText = '';
      redraw();
    }
  </script>
</body>
</html>
